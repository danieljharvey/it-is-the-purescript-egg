// Generated by purs version 0.13.5
"use strict";
var Control_Category = require("../Control.Category/index.js");
var Data_Array = require("../Data.Array/index.js");
var Data_Array_NonEmpty = require("../Data.Array.NonEmpty/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_EuclideanRing = require("../Data.EuclideanRing/index.js");
var Data_Foldable = require("../Data.Foldable/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Ordering = require("../Data.Ordering/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Egg_Types_Coord = require("../Egg.Types.Coord/index.js");
var Egg_Types_PathList = require("../Egg.Types.PathList/index.js");
var Egg_Types_PathMap = require("../Egg.Types.PathMap/index.js");
var Egg_Types_SmallCoord = require("../Egg.Types.SmallCoord/index.js");
var overflow = function ($copy_max) {
    return function ($copy_num) {
        var $tco_var_max = $copy_max;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(max, num) {
            if (num < 0) {
                $tco_var_max = max;
                $copy_num = max + num | 0;
                return;
            };
            if (num < max) {
                $tco_done = true;
                return num;
            };
            if (Data_Boolean.otherwise) {
                $tco_done = true;
                return Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(num)(max);
            };
            throw new Error("Failed pattern match at Egg.Logic.PathFinder (line 25, column 1 - line 25, column 30): " + [ max.constructor.name, num.constructor.name ]);
        };
        while (!$tco_done) {
            $tco_result = $tco_loop($tco_var_max, $copy_num);
        };
        return $tco_result;
    };
};
var wrapCoord = function (size) {
    return function (v) {
        var y$prime = overflow(size.height)(v.value1);
        var x$prime = overflow(size.width)(v.value0);
        return new Egg_Types_SmallCoord.SmallCoord(x$prime, y$prime);
    };
};
var listToDirection = function (list) {
    var current = Egg_Types_SmallCoord.toCoord(Data_Array_NonEmpty.last(list));
    var secondLast = Data_Maybe.fromMaybe(current)(Data_Functor.map(Data_Maybe.functorMaybe)(Egg_Types_SmallCoord.toCoord)(Data_Array_NonEmpty.index(Data_Array_NonEmpty.reverse(list))(1)));
    return Egg_Types_Coord.directionCoord(current)(secondLast);
};
var findAdjacent = function (pathMap) {
    return function (previous) {
        return function (coord) {
            var item = function (coord$prime) {
                var $7 = Egg_Types_PathMap.checkSquare(pathMap)(coord$prime) && Data_Foldable.notElem(Data_Foldable.foldableArray)(Egg_Types_SmallCoord.eqSmallCoord)(coord$prime)(previous);
                if ($7) {
                    return [ coord$prime ];
                };
                return [  ];
            };
            return Data_Array.concat([ item(Data_Semigroup.append(Egg_Types_SmallCoord.semigroupSmallCoord)(coord)(new Egg_Types_SmallCoord.SmallCoord(-1 | 0, 0))), item(Data_Semigroup.append(Egg_Types_SmallCoord.semigroupSmallCoord)(coord)(new Egg_Types_SmallCoord.SmallCoord(1, 0))), item(Data_Semigroup.append(Egg_Types_SmallCoord.semigroupSmallCoord)(coord)(new Egg_Types_SmallCoord.SmallCoord(0, -1 | 0))), item(Data_Semigroup.append(Egg_Types_SmallCoord.semigroupSmallCoord)(coord)(new Egg_Types_SmallCoord.SmallCoord(0, 1))) ]);
        };
    };
};
var itemListToNewList = function (pathMap) {
    return function (previous) {
        return function (items) {
            var currentLocation = Data_Array_NonEmpty.head(items);
            var newLocations = findAdjacent(pathMap)(previous)(currentLocation);
            var newArrays = Data_Functor.map(Data_Functor.functorArray)(function (i) {
                return Data_Array_NonEmpty.cons(i)(items);
            })(newLocations);
            return Data_Foldable.foldMap(Data_Foldable.foldableArray)(Egg_Types_PathList.monoidPathList)(Egg_Types_PathList.itemToList)(newArrays);
        };
    };
};
var iteratePathList = function (pathMap) {
    return function (items) {
        var allLists = Egg_Types_PathList.listToItems(items);
        var newLists = Data_Functor.map(Data_Functor.functorArray)(itemListToNewList(pathMap)(Egg_Types_PathList.getPreviouslyFound(items)))(allLists);
        return Data_Foldable.foldMap(Data_Foldable.foldableArray)(Egg_Types_PathList.monoidPathList)(Control_Category.identity(Control_Category.categoryFn))(newLists);
    };
};
var seekUntil = function ($copy_pathMap) {
    return function ($copy_seekCoord) {
        return function ($copy_limit) {
            return function ($copy_list) {
                var $tco_var_pathMap = $copy_pathMap;
                var $tco_var_seekCoord = $copy_seekCoord;
                var $tco_var_limit = $copy_limit;
                var $tco_done = false;
                var $tco_result;
                function $tco_loop(pathMap, seekCoord, limit, list) {
                    if (!Egg_Types_PathList.isKey(seekCoord)(list) && limit > 0) {
                        $tco_var_pathMap = pathMap;
                        $tco_var_seekCoord = seekCoord;
                        $tco_var_limit = limit - 1 | 0;
                        $copy_list = iteratePathList(pathMap)(list);
                        return;
                    };
                    if (Egg_Types_PathList.isKey(seekCoord)(list)) {
                        $tco_done = true;
                        return Egg_Types_PathList.lookup(seekCoord)(list);
                    };
                    if (Data_Boolean.otherwise) {
                        $tco_done = true;
                        return Data_Maybe.Nothing.value;
                    };
                    throw new Error("Failed pattern match at Egg.Logic.PathFinder (line 68, column 1 - line 68, column 94): " + [ pathMap.constructor.name, seekCoord.constructor.name, limit.constructor.name, list.constructor.name ]);
                };
                while (!$tco_done) {
                    $tco_result = $tco_loop($tco_var_pathMap, $tco_var_seekCoord, $tco_var_limit, $copy_list);
                };
                return $tco_result;
            };
        };
    };
};
var compareNEALengths = function (a) {
    return function (b) {
        if (Data_Array_NonEmpty.length(a) < Data_Array_NonEmpty.length(b)) {
            return Data_Ordering.LT.value;
        };
        if (Data_Array_NonEmpty.length(a) > Data_Array_NonEmpty.length(b)) {
            return Data_Ordering.GT.value;
        };
        if (Data_Boolean.otherwise) {
            return Data_Ordering.EQ.value;
        };
        throw new Error("Failed pattern match at Egg.Logic.PathFinder (line 113, column 1 - line 113, column 86): " + [ a.constructor.name, b.constructor.name ]);
    };
};
var chooseDirection = function (pathMap) {
    return function (targets) {
        return function (current) {
            var limit = (Egg_Types_PathMap.getMapSize(pathMap)).width;
            var initial = Egg_Types_PathList.singleton(Egg_Types_SmallCoord.fromCoord(current));
            var possibilities = Data_Array.catMaybes(Data_Functor.map(Data_Functor.functorArray)(function (coord) {
                return seekUntil(pathMap)(Egg_Types_SmallCoord.fromCoord(coord))(limit)(initial);
            })(targets));
            var sorted = Data_Array.head(Data_Array.sortBy(compareNEALengths)(possibilities));
            return Data_Functor.map(Data_Maybe.functorMaybe)(listToDirection)(sorted);
        };
    };
};
module.exports = {
    wrapCoord: wrapCoord,
    overflow: overflow,
    iteratePathList: iteratePathList,
    itemListToNewList: itemListToNewList,
    findAdjacent: findAdjacent,
    seekUntil: seekUntil,
    chooseDirection: chooseDirection,
    listToDirection: listToDirection,
    compareNEALengths: compareNEALengths
};
