// Generated by purs version 0.13.5
"use strict";
var Data_Array = require("../Data.Array/index.js");
var Data_Boolean = require("../Data.Boolean/index.js");
var Data_Eq = require("../Data.Eq/index.js");
var Data_EuclideanRing = require("../Data.EuclideanRing/index.js");
var Data_Functor = require("../Data.Functor/index.js");
var Data_Int = require("../Data.Int/index.js");
var Data_Maybe = require("../Data.Maybe/index.js");
var Data_Semigroup = require("../Data.Semigroup/index.js");
var Egg_Logic_Board = require("../Egg.Logic.Board/index.js");
var Egg_Types_Coord = require("../Egg.Types.Coord/index.js");
var Egg_Types_CurrentFrame = require("../Egg.Types.CurrentFrame/index.js");
var Egg_Types_LastAction = require("../Egg.Types.LastAction/index.js");
var Egg_Types_TileAction = require("../Egg.Types.TileAction/index.js");
var Matrix = require("../Matrix/index.js");
var speedConst = 20;
var playerHasMoved = function (old) {
    return function ($$new) {
        return Data_Eq.notEq(Egg_Types_Coord.eqCoord)(old.coords)($$new.coords);
    };
};
var moveDivision = 64;
var markPlayerIfMoved = function (old) {
    return function ($$new) {
        return {
            coords: $$new.coords,
            direction: $$new.direction,
            oldDirection: $$new.oldDirection,
            currentFrame: $$new.currentFrame,
            id: $$new.id,
            falling: $$new.falling,
            stop: $$new.stop,
            lastAction: $$new.lastAction,
            moved: playerHasMoved(old)($$new),
            playerType: $$new.playerType
        };
    };
};
var mapCoords = function (f) {
    return function (player) {
        return {
            coords: f(player.coords),
            direction: player.direction,
            oldDirection: player.oldDirection,
            currentFrame: player.currentFrame,
            id: player.id,
            falling: player.falling,
            stop: player.stop,
            lastAction: player.lastAction,
            moved: player.moved,
            playerType: player.playerType
        };
    };
};
var isStationary = function (v) {
    if (v.x === 0 && (v.y === 0 && (v.offsetX === 0 && v.offsetY === 0))) {
        return true;
    };
    return false;
};
var resetDirectionWhenStationary = function (player) {
    var $23 = isStationary(player.coords);
    if ($23) {
        return {
            coords: player.coords,
            direction: player.direction,
            oldDirection: Egg_Types_Coord.createCoord(0)(0),
            currentFrame: player.currentFrame,
            id: player.id,
            falling: player.falling,
            stop: player.stop,
            lastAction: player.lastAction,
            moved: player.moved,
            playerType: player.playerType
        };
    };
    return player;
};
var getAllTeleports = function (coord) {
    return function (board) {
        var filterFunc = function (a) {
            return Data_Eq.eq(Egg_Types_TileAction.eqTileAction)(a.value.action)(Egg_Types_TileAction.Teleport.value) && !Egg_Types_Coord.eqInts(coord)(a.x)(a.y);
        };
        return Data_Array.filter(filterFunc)(Matrix.toIndexedArray(board));
    };
};
var correctTileOverflow = function ($copy_v) {
    var $tco_done = false;
    var $tco_result;
    function $tco_loop(v) {
        if (v.offsetX >= moveDivision) {
            $tco_done = true;
            return Egg_Types_Coord.createCoord(v.x + 1 | 0)(v.y);
        };
        if (v.offsetX <= ((-1 | 0) * moveDivision | 0)) {
            $tco_done = true;
            return Egg_Types_Coord.createCoord(v.x - 1 | 0)(v.y);
        };
        if (v.offsetY >= moveDivision) {
            $copy_v = Egg_Types_Coord.createCoord(v.x)(v.y + 1 | 0);
            return;
        };
        if (v.offsetY <= ((-1 | 0) * moveDivision | 0)) {
            $copy_v = Egg_Types_Coord.createCoord(v.x)(v.y - 1 | 0);
            return;
        };
        if (Data_Boolean.otherwise) {
            $tco_done = true;
            return v;
        };
        throw new Error("Failed pattern match at Egg.Logic.Movement (line 101, column 1 - line 101, column 38): " + [ v.constructor.name ]);
    };
    while (!$tco_done) {
        $tco_result = $tco_loop($copy_v);
    };
    return $tco_result;
};
var correctPlayerOverflow = function (player) {
    var movedPlayer = mapCoords(correctTileOverflow)(player);
    var $25 = Data_Eq.eq(Egg_Types_Coord.eqCoord)(movedPlayer.coords)(player.coords);
    if ($25) {
        return player;
    };
    return {
        coords: movedPlayer.coords,
        direction: movedPlayer.direction,
        oldDirection: movedPlayer.oldDirection,
        currentFrame: movedPlayer.currentFrame,
        id: movedPlayer.id,
        falling: movedPlayer.falling,
        stop: movedPlayer.stop,
        lastAction: Data_Maybe.Nothing.value,
        moved: movedPlayer.moved,
        playerType: movedPlayer.playerType
    };
};
var correctMapOverflow = function (size) {
    return function (v) {
        var y = Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(v.y)(size.height);
        var x = Data_EuclideanRing.mod(Data_EuclideanRing.euclideanRingInt)(v.x)(size.width);
        return Egg_Types_Coord.Coord({
            x: x,
            y: y,
            offsetX: v.offsetX,
            offsetY: v.offsetY
        });
    };
};
var correctPlayerMapOverflow = function (board) {
    return mapCoords(correctMapOverflow(Egg_Logic_Board.boardSizeFromBoard(board)));
};
var checkPlayerDirection = function (board) {
    return function (player) {
        var coord = Data_Semigroup.append(Egg_Types_Coord.semigroupCoord)(player.coords)(player.direction);
        var nextTile = Egg_Logic_Board.getTileByCoord(board)(coord);
        var newDirection = (function () {
            var $28 = nextTile.background || player.falling;
            if ($28) {
                return player.direction;
            };
            return Egg_Types_Coord.invert(player.direction);
        })();
        return {
            coords: player.coords,
            direction: newDirection,
            oldDirection: player.oldDirection,
            currentFrame: player.currentFrame,
            id: player.id,
            falling: player.falling,
            stop: player.stop,
            lastAction: player.lastAction,
            moved: player.moved,
            playerType: player.playerType
        };
    };
};
var checkMovementTile = function (board) {
    return function (player) {
        var currentTile = Egg_Logic_Board.getTileByCoord(board)(player.coords);
        var $29 = Data_Eq.eq(Data_Maybe.eqMaybe(Egg_Types_LastAction.eqLastAction))(player.lastAction)(new Data_Maybe.Just(Egg_Types_LastAction.Teleported.value));
        if ($29) {
            return player;
        };
        if (currentTile.action instanceof Egg_Types_TileAction.Teleport) {
            var v = Data_Array.head(getAllTeleports(player.coords)(board));
            if (v instanceof Data_Maybe.Just) {
                return {
                    coords: Egg_Types_Coord.createCoord(v.value0.x)(v.value0.y),
                    direction: player.direction,
                    oldDirection: player.oldDirection,
                    currentFrame: player.currentFrame,
                    id: player.id,
                    falling: player.falling,
                    stop: player.stop,
                    lastAction: new Data_Maybe.Just(Egg_Types_LastAction.Teleported.value),
                    moved: player.moved,
                    playerType: player.playerType
                };
            };
            if (v instanceof Data_Maybe.Nothing) {
                return player;
            };
            throw new Error("Failed pattern match at Egg.Logic.Movement (line 153, column 17 - line 159, column 24): " + [ v.constructor.name ]);
        };
        return player;
    };
};
var checkFloorBelowPlayer = function (board) {
    return function (player) {
        var coord = Data_Semigroup.append(Egg_Types_Coord.semigroupCoord)(player.coords)(Egg_Types_Coord.createCoord(0)(1));
        var canFall = !player.playerType.flying;
        var belowTile = Egg_Logic_Board.getTileByCoord(board)(coord);
        var breakable = belowTile.breakable && player.falling;
        return {
            coords: player.coords,
            direction: player.direction,
            oldDirection: player.oldDirection,
            currentFrame: player.currentFrame,
            id: player.id,
            falling: canFall && (breakable || belowTile.background),
            stop: player.stop,
            lastAction: player.lastAction,
            moved: player.moved,
            playerType: player.playerType
        };
    };
};
var changeFrameIfMoving = function (v) {
    if (v.direction.x < 0) {
        return {
            coords: v.coords,
            direction: v.direction,
            oldDirection: v.oldDirection,
            currentFrame: Egg_Types_CurrentFrame.dec(v.currentFrame),
            id: v.id,
            falling: v.falling,
            stop: v.stop,
            lastAction: v.lastAction,
            moved: v.moved,
            playerType: v.playerType
        };
    };
    if (v.direction.x > 0) {
        return {
            coords: v.coords,
            direction: v.direction,
            oldDirection: v.oldDirection,
            currentFrame: Egg_Types_CurrentFrame.inc(v.currentFrame),
            id: v.id,
            falling: v.falling,
            stop: v.stop,
            lastAction: v.lastAction,
            moved: v.moved,
            playerType: v.playerType
        };
    };
    if (v.direction.y < 0) {
        return {
            coords: v.coords,
            direction: v.direction,
            oldDirection: v.oldDirection,
            currentFrame: Egg_Types_CurrentFrame.dec(v.currentFrame),
            id: v.id,
            falling: v.falling,
            stop: v.stop,
            lastAction: v.lastAction,
            moved: v.moved,
            playerType: v.playerType
        };
    };
    if (v.direction.y > 0) {
        return {
            coords: v.coords,
            direction: v.direction,
            oldDirection: v.oldDirection,
            currentFrame: Egg_Types_CurrentFrame.inc(v.currentFrame),
            id: v.id,
            falling: v.falling,
            stop: v.stop,
            lastAction: v.lastAction,
            moved: v.moved,
            playerType: v.playerType
        };
    };
    if (Data_Boolean.otherwise) {
        return v;
    };
    throw new Error("Failed pattern match at Egg.Logic.Movement (line 44, column 1 - line 44, column 40): " + [ v.constructor.name ]);
};
var incrementPlayerFrame = function ($36) {
    return resetDirectionWhenStationary(changeFrameIfMoving($36));
};
var calcMoveAmount = function (moveSpeed) {
    return function (timePassed) {
        var moveAmount = (1.0 / Data_Int.toNumber(moveDivision)) * Data_Int.toNumber(moveSpeed) * Data_Int.toNumber(speedConst);
        return Data_Int.floor(moveAmount * Data_Int.toNumber(timePassed));
    };
};
var incrementPlayerDirection = function (timePassed) {
    return function (player) {
        var moveAmount = calcMoveAmount(player.playerType.moveSpeed)(timePassed);
        var fallAmount = calcMoveAmount(player.playerType.fallSpeed)(timePassed);
        var newCoords = (function () {
            if (player.falling) {
                return Data_Semigroup.append(Egg_Types_Coord.semigroupCoord)(player.coords)(Egg_Types_Coord.createMoveCoord(fallAmount)(Egg_Types_Coord.createCoord(0)(1)));
            };
            return Data_Semigroup.append(Egg_Types_Coord.semigroupCoord)(player.coords)(Egg_Types_Coord.createMoveCoord(moveAmount)(player.direction));
        })();
        return {
            coords: newCoords,
            direction: player.direction,
            oldDirection: player.oldDirection,
            currentFrame: player.currentFrame,
            id: player.id,
            falling: player.falling,
            stop: player.stop,
            lastAction: player.lastAction,
            moved: player.moved,
            playerType: player.playerType
        };
    };
};
var movePlayer = function (board) {
    return function (timePassed) {
        return function (player) {
            var doMove = (function () {
                var $37 = markPlayerIfMoved(player);
                var $38 = correctPlayerMapOverflow(board);
                var $39 = checkPlayerDirection(board);
                var $40 = checkFloorBelowPlayer(board);
                var $41 = checkMovementTile(board);
                var $42 = incrementPlayerDirection(timePassed);
                return function ($43) {
                    return $37($38(incrementPlayerFrame($39($40($41(correctPlayerOverflow($42($43))))))));
                };
            })();
            return doMove(player);
        };
    };
};
var movePlayers = function (board) {
    return function (i) {
        return Data_Functor.map(Data_Functor.functorArray)(movePlayer(board)(i));
    };
};
module.exports = {
    moveDivision: moveDivision,
    speedConst: speedConst,
    movePlayers: movePlayers,
    movePlayer: movePlayer,
    incrementPlayerFrame: incrementPlayerFrame,
    changeFrameIfMoving: changeFrameIfMoving,
    resetDirectionWhenStationary: resetDirectionWhenStationary,
    isStationary: isStationary,
    calcMoveAmount: calcMoveAmount,
    incrementPlayerDirection: incrementPlayerDirection,
    correctPlayerOverflow: correctPlayerOverflow,
    correctPlayerMapOverflow: correctPlayerMapOverflow,
    mapCoords: mapCoords,
    correctTileOverflow: correctTileOverflow,
    correctMapOverflow: correctMapOverflow,
    checkFloorBelowPlayer: checkFloorBelowPlayer,
    markPlayerIfMoved: markPlayerIfMoved,
    playerHasMoved: playerHasMoved,
    checkPlayerDirection: checkPlayerDirection,
    checkMovementTile: checkMovementTile,
    getAllTeleports: getAllTeleports
};
